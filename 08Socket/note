
Socket编程
互联网的本质就是一系列的网络协议
人们按照分工的不同把互联网协议从逻辑上划分了层次

底层的物理链接介质
网卡

物理层         - 比特流 二进制 高低电平 010101010.....00001111....00000 没有开头没有结尾没有意义--> 需要分组
数据链路层     - 比特流分组，Ethernet协议定义电信号的分组方式：一组电信号构成一个数据包，叫做帧
                -- head + data
                -- 基于mac地址的广播协议
                -- 广播的方式进行通信，即计算机通信基本靠吼
                -- 广播限定在广播域内

网络层         - 网络IP/掩码  IP定位到子网，ARP协议可以将IP映射到MAC
传输层         - 标识哪个软件，绑定端口，唯一标识这台机器是哪个软件
应用层         - https，http，ssh

我们开发的是应用层软件，必须学习TCP/UDP协议---> 累死
Socket是应用层与TCP/IP协议族中间的抽象层，它是一组接口，我们只要遵循Socket接口，那就相当于遵循TCP/IP协议啦

Socket 套接字 一开始用于进程间通信
基于文件类型的Socket，UNIX一切皆文件，两个进程都可以操作同一文件，就相当于通信了 AF_UNIX
基于网络类型的Socket，AF_INET


黏包问题主要是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的
只有TCP有黏包现象，UDP永远不会黏包

用户态 send() recv() 发起系统调用，转到内核态
内核态 OS调用硬件

客户端发 -> 发给自己的缓存；服务端收 <- 从发自己的缓存收，不是我们所想客户端直接发给服务端
黏包只跟自己缓存有关


